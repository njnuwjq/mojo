package genproto

import (
	"bytes"
	"fmt"
	"github.com/golang/protobuf/proto"
	"log"
	"os"
	"strings"
)

// A Plugin provides functionality to add to the output during Go code generation,
// such as to produce RPC stubs.
type Plugin interface {
	// Name identifies the plugin.
	Name() string
	// Init is called once after data structures are built but before
	// code generation begins.
	Init(g *Generator)
	// Generate produces the code generated by the plugin for this file,
	// except for the imports, by calling the generator's methods P, In, and Out.
	Generate(file *FileDescriptor)
	// GenerateImports produces the import declarations for this file.
	// It is called after Generate.
	GenerateImports(file *FileDescriptor)
}

var plugins []Plugin

// Generator is the type whose methods generate the output, stored in the associated response structure.
type Generator struct {
	*bytes.Buffer

	Request  *CodeGeneratorRequest  // The input.
	Response *CodeGeneratorResponse // The output.

	Param        map[string]string // Command-line parameters.
	ImportPrefix string            // String to prefix to imported package file names.
	ImportMap    map[string]string // Mapping from .proto file name to import path

	Pkg map[string]string // The names under which we import support packages

	genFiles []*FileDescriptor // Those files we will generate output for.

	allFiles       []*FileDescriptor          // All files in the tree
	allFilesByName map[string]*FileDescriptor // All files by filename.

	file *FileDescriptor // The file we are compiling now.

	indent      string
	writeOutput bool
}

// New creates a new generator and allocates the request and response protobufs.
func New(files []*FileDescriptor) *Generator {
	g := new(Generator)
	g.Buffer = new(bytes.Buffer)
	g.Request = new(CodeGeneratorRequest)
	g.Response = new(CodeGeneratorResponse)

	if len(files) > 0 {
		for _, file := range files {
			g.allFiles = append(g.allFiles, file)
		}
		g.genFiles = g.allFiles
	}

	return g
}

// Error reports a problem, including an error, and exits the program.
func (g *Generator) Error(err error, msgs ...string) {
	s := strings.Join(msgs, " ") + ":" + err.Error()
	log.Print("protoc-gen-proto: error:", s)
	os.Exit(1)
}

// Fail reports a problem and exits the program.
func (g *Generator) Fail(msgs ...string) {
	s := strings.Join(msgs, " ")
	log.Print("protoc-gen-proto: error:", s)
	os.Exit(1)
}

// printAtom prints the (atomic, non-annotation) argument to the generated output.
func (g *Generator) printAtom(v interface{}) {
	switch v := v.(type) {
	case string:
		g.WriteString(v)
	case *string:
		g.WriteString(*v)
	case bool:
		fmt.Fprint(g, v)
	case *bool:
		fmt.Fprint(g, *v)
	case int:
		fmt.Fprint(g, v)
	case *int32:
		fmt.Fprint(g, *v)
	case *int64:
		fmt.Fprint(g, *v)
	case float64:
		fmt.Fprint(g, v)
	case *float64:
		fmt.Fprint(g, *v)
	default:
		g.Fail(fmt.Sprintf("unknown type in printer: %T", v))
	}
}

// P prints the arguments to the generated output.  It handles strings and int32s, plus
// handling indirections because they may be *string, etc.  Any inputs of type AnnotatedAtoms may emit
// annotations in a .meta file in addition to outputting the atoms themselves (if g.annotateCode
// is true).
func (g *Generator) P(str ...interface{}) {
	if !g.writeOutput {
		return
	}
	g.WriteString(g.indent)
	for _, v := range str {
		switch v := v.(type) {
		default:
			g.printAtom(v)
		}
	}
	g.WriteByte('\n')
}

// deprecationComment is the standard comment added to deprecated
// messages, fields, enums, and enum values.
var deprecationComment = "// Deprecated: Do not use."

// PrintComments prints any comments from the source .proto file.
// The path is a comma-separated list of integers.
// It returns an indication of whether any comments were printed.
// See descriptor.proto for its format.
func (g *Generator) PrintComments(path string) bool {
	if !g.writeOutput {
		return false
	}
	if c, ok := g.makeComments(path); ok {
		g.P(c)
		return true
	}
	return false
}

// makeComments generates the comment string for the field, no "\n" at the end
func (g *Generator) makeComments(path string) (string, bool) {
	loc, ok := g.file.Comments[path]
	if !ok {
		return "", false
	}
	w := new(bytes.Buffer)
	nl := ""
	for _, line := range strings.Split(strings.TrimSuffix(loc.GetLeadingComments(), "\n"), "\n") {
		fmt.Fprintf(w, "%s//%s", nl, line)
		nl = "\n"
	}
	return w.String(), true
}

// In Indents the output one tab stop.
func (g *Generator) In() { g.indent += "    " }

// Out unindents the output one tab stop.
func (g *Generator) Out() {
	if len(g.indent) > 0 {
		g.indent = g.indent[4:]
	}
}

// WrapTypes walks the incoming data, wrapping DescriptorProtos, EnumDescriptorProtos
// and FileDescriptorProtos into file-referenced objects within the Generator.
// It also creates the list of files to generate and so should be called before GenerateAllFiles.
func (g *Generator) WrapTypes() {
	g.allFiles = make([]*FileDescriptor, 0, len(g.Request.ProtoFile))
	g.allFilesByName = make(map[string]*FileDescriptor, len(g.allFiles))
	genFileNames := make(map[string]bool)
	for _, n := range g.Request.FileToGenerate {
		genFileNames[n] = true
	}
	for _, f := range g.Request.ProtoFile {
		fd := &FileDescriptor{
			FileDescriptorProto: f,
			Proto3:              FileIsProto3(f),
		}

		// We must wrap the descriptors before we wrap the enums
		fd.Messages = WrapMessageDescriptors(fd)
		g.buildNestedDescriptors(fd.Messages)

		fd.Enums = WrapEnumDescriptors(fd, fd.Messages)
		g.buildNestedEnums(fd.Messages, fd.Enums)

		ExtractComments(fd)
		g.allFiles = append(g.allFiles, fd)
		g.allFilesByName[f.GetName()] = fd
	}

	g.genFiles = make([]*FileDescriptor, 0, len(g.Request.FileToGenerate))
	for _, fileName := range g.Request.FileToGenerate {
		fd := g.allFilesByName[fileName]
		if fd == nil {
			g.Fail("could not find file named", fileName)
		}
		g.genFiles = append(g.genFiles, fd)
	}
}

// Scan the descriptors in this file.  For each one, build the slice of nested descriptors
func (g *Generator) buildNestedDescriptors(descs []*MessageDescriptor) {
	for _, desc := range descs {
		if len(desc.NestedType) != 0 {
			for _, nest := range descs {
				if nest.Parent == desc {
					desc.Messages = append(desc.Messages, nest)
				}
			}
			if len(desc.Messages) != len(desc.NestedType) {
				g.Fail("internal error: nesting failure for", desc.GetName())
			}
		}
	}
}

func (g *Generator) buildNestedEnums(descs []*MessageDescriptor, enums []*EnumDescriptor) {
	for _, desc := range descs {
		if len(desc.EnumType) != 0 {
			for _, enum := range enums {
				if enum.Parent == desc {
					desc.Enums = append(desc.Enums, enum)
				}
			}
			if len(desc.Enums) != len(desc.EnumType) {
				g.Fail("internal error: enum nesting failure for", desc.GetName())
			}
		}
	}
}

func (g *Generator) WriteAllFiles(dir string) {
	fmt.Sprint(dir)
}

// GenerateAllFiles generates the output for all the files we're outputting.
func (g *Generator) GenerateAllFiles() *Generator {
	// Initialize the plugins
	for _, p := range plugins {
		p.Init(g)
	}
	// Generate the output. The generator runs for every file, even the files
	// that we don't generate output for, so that we can collate the full list
	// of exported symbols to support public imports.
	genFileMap := make(map[*FileDescriptor]bool, len(g.genFiles))
	for _, file := range g.genFiles {
		genFileMap[file] = true
	}
	for _, file := range g.allFiles {
		g.Reset()
		g.writeOutput = genFileMap[file]
		g.generate(file)
		if !g.writeOutput {
			continue
		}
		g.Response.File = append(g.Response.File, &CodeGeneratorResponse_File{
			Name:    proto.String(*file.Name),
			Content: proto.String(g.String()),
		})
	}

	return g
}

// Fill the response protocol buffer with the generated output for all the files we're
// supposed to generate.
func (g *Generator) generate(file *FileDescriptor) {
	g.file = file

	for _, enum := range g.file.Enums {
		if enum.Parent == nil {
			g.P()
			g.generateEnum(enum)
		}
	}

	for _, message := range g.file.Messages {
		if message.Parent == nil {
			g.P()
			g.generateMessage(message)
		}
	}

	for _, service := range g.file.Services {
		g.P()
		g.generateService(service)
	}

	// Run the plugins before the imports so we know which imports are necessary.
	//g.runPlugins(file)

	// Generate header and imports last, though they appear first in the output.
	rem := g.Buffer
	g.Buffer = new(bytes.Buffer)
	g.generateHeader()
	g.P()
	g.generateImports()
	//if !g.writeOutput {
	//	return
	//}

	g.Write(rem.Bytes())
}

// Generate the header, including package definition
func (g *Generator) generateHeader() {
	g.P("// Code generated by protoc-gen-proto. DO NOT EDIT.")
	if g.file.GetOptions().GetDeprecated() {
		g.P("// ", g.file.Name, " is a deprecated file.")
	}

	g.P()
	g.P("// This is a compile-time assertion to ensure that this generated file")
	g.P("// is compatible with the proto package it is being compiled against.")
	g.P("// A compilation error at this line likely means your copy of the")
	g.P("// proto package needs to be updated.")

	g.P()

	syntax := "proto3"
	if g.file.Syntax != nil {
		syntax = *g.file.Syntax
	}
	g.P("syntax = ", syntax, ";")

	if g.file.Package != nil {
		g.P()
		g.P("package ", g.file.Package, ";")
	} else {
		// error
	}
}

func (g *Generator) generateImports() {
	for _, imp := range g.file.Dependency {
		g.P("import ", imp, ";")
	}
}

// Generate the enum definitions for this EnumDescriptor.
func (g *Generator) generateEnum(enum *EnumDescriptor) {
	if enum.GetOptions().GetDeprecated() {
		g.P("// ", deprecationComment)
	}

	g.P("enum ", enum.Name, " {")

	for _, e := range enum.Value {
		if e.GetOptions().GetDeprecated() {
			g.P()
			g.P("// ", deprecationComment)
		}

		g.P(e.Name, "=", e.Number)
	}

	g.P("}")
}

var fieldDescriptorProtoTypeName = map[FieldDescriptorProto_Type]string{
	FieldDescriptorProto_TYPE_STRING: "string",
	FieldDescriptorProto_TYPE_BOOL: "bool",
	FieldDescriptorProto_TYPE_INT32: "int32",
	FieldDescriptorProto_TYPE_UINT32: "uint32",
	FieldDescriptorProto_TYPE_INT64: "int64",
	FieldDescriptorProto_TYPE_UINT64: "uint64",
	FieldDescriptorProto_TYPE_FLOAT: "float",
	FieldDescriptorProto_TYPE_DOUBLE: "double",
	FieldDescriptorProto_TYPE_BYTES: "bytes",
}

func getFieldTypeName(field *FieldDescriptorProto) string {
	t := fieldDescriptorProtoTypeName[*field.Type]
	if len(t) > 0 {
		return t
	} else {
		return field.GetTypeName()
	}
}

// Generate the type, methods and default constant definitions for this Descriptor.
func (g *Generator) generateMessage(message *MessageDescriptor) {
	// Build a structure more suitable for generating the text in one pass
	for _, enum := range message.Enums {
		g.P()
		g.generateEnum(enum)
	}

	for _, msg := range message.Messages {
		g.P()
		if msg.Options != nil && msg.Options.MapEntry != nil && *msg.Options.MapEntry {
			continue
		}

		g.generateMessage(msg)
	}

	g.P("message ", message.Name, " {")

	for _, field := range message.Field {
		/*
			oneof := field.OneofIndex != nil
			if oneof && oFields[*field.OneofIndex] == nil {
				odp := message.OneofDecl[int(*field.OneofIndex)]

				// This is the first field of a oneof we haven't seen before.
				// Generate the union field.
				oneofFullPath := fmt.Sprintf("%s,%d,%d", message.path, messageOneofPath, *field.OneofIndex)
				c, ok := g.makeComments(oneofFullPath)
				if ok {
					c += "\n//\n"
				}
				c += "// Types that are valid to be assigned to " + fname + ":\n"
				// Generate the rest of this comment later,
				// when we've computed any disambiguation.

				dname := "is" + goTypeName + "_" + fname
				tag := `protobuf_oneof:"` + odp.GetName() + `"`
				of := oneofField{
					fieldCommon: fieldCommon{
						goName:     fname,
						getterName: gname,
						goType:     dname,
						tags:       tag,
						protoName:  odp.GetName(),
						fullPath:   oneofFullPath,
					},
					comment: c,
				}
				topLevelFields = append(topLevelFields, &of)
				oFields[*field.OneofIndex] = &of
			}*/

		if *field.Type == FieldDescriptorProto_TYPE_MESSAGE {
			desc := message.GetInnerMessage(field.GetTypeName())
			if desc != nil && desc.GetOptions() != nil && desc.GetOptions().GetMapEntry() {
				keyType := desc.Field[0].TypeName
				valType := desc.Field[1].TypeName
				g.P("map<", keyType, valType, "> ", field.Name, " = ", field.Number, ";")
				continue
			}
		}

		//fieldDeprecated := ""
		//if field.GetOptions().GetDeprecated() {
		//	fieldDeprecated = deprecationComment
		//}

		if field.Label != nil && field.GetLabel() == FieldDescriptorProto_LABEL_REPEATED {
			g.P("repeated ", getFieldTypeName(field), " ", field.GetName(), " = ", field.Number, ";")
		} else {
			g.P(getFieldTypeName(field), " ", field.GetName(), " = ", field.Number, ";")
		}

		//fieldFullPath := fmt.Sprintf("%s,%d,%d", message.path, messageFieldPath, i)
		//c, ok := g.makeComments(fieldFullPath)
		//if ok {
		//	c += "\n"
		//}
	}

	g.P("}")
}

// Generate the type, methods and default constant definitions for this Descriptor.
func (g *Generator) generateService(service *ServiceDescriptor) {
	g.P("service ", service.Name, " {")

	for _, method := range service.Method {
		g.P("rpc ", method.Name, "(", method.InputType, ") returns (", method.OutputType, ");")
	}

	g.P("}")
}
